[{"title":"基础学习_01","date":"2018-03-19T16:40:36.000Z","path":"2018/03/20/基础学习-01-md/","text":"LocalBroadcastManager 1实现方式是handler 和 广播的形式 activity 12345注册广播尽量在onStart 和 onStop 中 注册 和 反注册页面不可见时的触发要在onPause中保存保证数据的有效性onStop保存有可能会被回收假如A页面的数据写数据库B页面要用的话,需要在onPause保证有效性当手机长时间不操作黑屏以后，再次打开的时候由于activity没有被销毁就会执行onResume方法，而不是执行onStart方法！ 如何判断一个activity是否被销毁 1234//低版本是否支持可用的兼容问题4.2引入(Build.VERSION.SDK_INT &lt; 17)if (activity == null || activity.isDestroyed() || activity.isFinishing())&#123; return; &#125; View 屏幕旋转状态的保存问题 1234567sdk1.6以前Activity转屏时EditText是不会保存状态的对SavedState的理解Activity的onSaveInstanceState和onRestoreInstanceState的理解和存储Activity类的onSaveInstanceState默认实现会恢复Activity的状态，默认实现会为布局中的每个View调用相应的 onSaveInstanceState方法，让每个View都能保存自身的信息。setId和setSaveEnabled()才会使View去保存信息布局文件中公用同一个id的时候最后一个View保存的状态会把之前相同id的View的状态覆盖掉(确保View的id的唯一性) Parcelable和Serializable的区别 12345678910Serializalbe会使用反射，序列化和反序列化过程需要大量I/O操作，Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多1）. 在内存的使用中,前者在性能方面要强于后者2）. 后者在序列化操作的时候会产生大量的临时变量,(原因是使用了反射机制)从而导致GC的频繁调用,因此在性能上会稍微逊色3）. Parcelable是以Ibinder作为信息载体的.在内存上的开销比较小,因此在内存之间进行数据传递的时候,Android推荐使用Parcelable,既然是内存方面比价有优势,那么自然就要优先选择.4）. 在读写数据的时候,Parcelable是在内存中直接进行读写,而Serializable是通过使用IO流的形式将数据读写入在硬盘上. 但是：虽然Parcelable的性能要强于Serializable,但是仍然有特殊的情况需要使用Serializable,而不去使用Parcelable,因为Parcelable无法将数据进行持久化,因此在将数据保存在磁盘的时候,仍然需要使用后者,因为前者无法很好的将数据进行持久化.(原因是在不同的Android版本当中,Parcelable可能会不同,因此数据的持久化方面仍然是使用Serializable) Parcelable和Parcle这两者之间的关系 1Parcelable 接口定义在封送/解封送过程中混合和分解对象的契约。Parcelable接口的底层是Parcel容器对象。Parcel类是一种最快的序列化/反序列化机制，专为Android中的进程间通信而设计。该类提供了一些方法来将成员容纳到容器中，以及从容器展开成员 ​","tags":[{"name":"基础学习","slug":"基础学习","permalink":"/dayanguai.website/tags/基础学习/"}]},{"title":"GreenDao的学习和问题","date":"2017-09-20T10:03:53.000Z","path":"2017/09/20/2017-09-20-GreenDao的学习和问题/","text":"GreenDao 遇到的知识点和问题在项目选择数据库的时候，纠结了下，是选择使用 Realm 还是 GreenDao 最后还是选择使用 GreenDao 之前使用过 Realm 坑有点多，还是试下 GreenDao ,改天写下 Realm 的坑。 这篇文章主要是记录下自己的学习过程。当然类似的很多嘛~ 之前greenDao3.0x之前是使用java代码去生成相对应的Dao和表数据代码，但是现在到3.0x 感觉对开发人员挺友好的。 咱们先按照文档上的来看下构建项目. 先放上连接GreenDao 添加依赖（官方文档）我一般情况下是新建个 Moudle 来专门放置 GreenDao .当然依照个人的编码方式来写嘛. 1234567891011// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.3' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2' // add plugin &#125;&#125; 在你的app层的 build.gradle 中添加 123456789101112131415161718// In your app projects build.gradle file:apply plugin: 'com.android.application'apply plugin: 'org.greenrobot.greendao' // apply plugin android &#123; ... //这段不添加也不会影响使用，他会自动生成代码到build/generated/source中 greendao &#123; schemaVersion 1 //数据库版本号 daoPackage 'cn.com.example.greendao'//设置DaoMaster、DaoSession、Dao包名 targetGenDir 'src/main/java'//设置DaoMaster、DaoSession、Dao目录 &#125; ...&#125;dependencies &#123; compile 'org.greenrobot:greendao:3.2.2' // add library&#125; 依赖添加基本上完事了. 使用 greenDao 数据库注解实体@Entity注解 12345678schema：告知GreenDao当前实体属于哪个schemaactive：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法nameInDb：在数据中使用的别名，默认使用的是实体的类名indexes：定义索引，可以跨越多个列createInDb：标记创建数据库表，m默认是true@Entity(schema = \"exampleSchema\",active = true,nameInDb = \"user\",createInDb = true)class ExampleUser&#123;&#125; 基础属性注解 12345678910111213141516@Id :主键 Long型，可以通过@Id(autoincrement = true)设置自增长@Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=&quot;name&quot;)@NotNul：设置数据库表当前列不能为空@Transient ：添加次标记之后不会生成数据库表的列class ExampleUser&#123; @Id(autoincrement = true) //自增id private Long id; @NotNull //名字不能为空 private String nickName; @Transient //表中不会存储该字段 private String password; @Property(nameInDb = &quot;xingbie&quot;) //表中存储的是&lt;xingbie&gt; 而不是&lt;sex&gt; private int sex;&#125; 索引注解 12@Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束@Unique：向数据库列添加了一个唯一的约束 关系注解 @ToOne：定义与另一个实体（一个实体对象）的关系 1234567891011121314151617181920212223/***插入的时候要注意了*一定要对应每个的Dao去插入.* UserDao.insert(new ExampleUser())* FriendDao.insert(new Friend())* 而且还要注意的点是 ExampleUser中的friendName一定要和 Friend中的nickName 对应不然你就会遇到坑了*/@Entity(nameInDb = &quot;user&quot;)class ExampleUser&#123; //对应的是Friend的实体 private String friendName; @ToOne(joinProperty = &quot;friendName&quot;) Friend mFriend; &#125;@Entity(nameInDb = &quot;friend&quot;)class Friend&#123; @Id String nickName; &#125; @ToMany：定义与多个实体对象的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551.一对多的关系@ToMany(referencedJoinProperty = \"XXXX\")一对多的关系，定义了一个实体对象对应着多个实体对象，比如一个用户对应多个Friend, 在建立数据表示会在目标实体（即一对多的那个多的实体类）的数据表中建立外键，指向源实体类（一对多中的一那个实体类）的数据表。目标数据表中的外键属性由@ToMany(referencedJoinProperty = \"XXXX\")指定。@Entity(nameInDb = \"user\")class ExampleUser&#123; //对应的是Friend的实体 private String friendName; @ToOne(joinProperty = \"friendName\") Friend mFriend; @ToMany(referencedJoinProperty = \"nickName\") //一对多的关系 List&lt;Friend&gt; friends; &#125;@Entity(nameInDb = \"friend\")class Friend&#123; @Id String nickName; &#125;2.属性指向属性@ToMany@JoinProperty(name = \"XXXX\", referencedName = \"YYYY\")可以建立目标实体类中YYYY属性指向源实体类XXXX的属性，其中YYYY为非空，XXXX为unique的，不一定是主键，这样的关系可以有多个@Entity(nameInDb = \"user\")class ExampleUser&#123; @Unique //唯一约束 private String friendName; @JoinProperty(name = \"friendName\", referencedName = \"nickName\") //一对多的关系 List&lt;Friend&gt; friends; &#125;@Entity(nameInDb = \"friend\")class Friend&#123; @NotNull @Id String nickName; &#125;3. 多对多的关系@ToMany@JoinEntity( entity = xxxx.class, sourceProperty = \"xxx\", targetProperty = \"xxx\" )用于将某个字段映射到另外一张表中.entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性 参考链接-ToMany 操作数据库12345678xxxDao.insert()、xxxDao.insertOrReplace()、xxxDao.save()这几个都是插入，但是是有区别的xxxDao.load(String key) 根据主键查询，得到具体的实体类，如果不存在则返回nullxxxDao.loadAll()得到全部数据集xxxDao.update() 更新数据xxxDao.deleteByKey() 根据逐渐删除xxxDao.deleteAll() 删除所有的xxxDao.detachAll() 删除所有的缓存(第一次查询慢，第二次假如缓存中有直接取出缓存，但是更新完毕后，再去取得话，记得清下当前表的缓存，不然拿出的还是之前的数据)xxxDao.queryBuilder() 提供各种方式的结果查询，比如进行有条件的查询，倒序等 insert()、insertOrReplace()和save()的区别 数据库升级首先在module的gradle文件中修改版本号： 12//改为最新的版本号 schemaVersion 2 然后(GreenDaoUpgradeHelper就没了。我接着去找坑去……","tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"/dayanguai.website/tags/GreenDao/"}]},{"title":"SVG遇到的知识点和问题","date":"2017-09-18T10:16:55.000Z","path":"2017/09/18/2017-09-18-SVG遇到的知识点和问题-md/","text":"SVG遇到的知识点和问题(Vector Drawable)之前项目太大。导致每次被喷。体积大，目前打算用下SVG体积小。而且支持也挺好的。就学习的时候记录下学习的东西和问题。 &lt;Path&gt;的绘制方法 12345678910M = moveto(M X,Y) ：将画笔移动到指定的坐标位置L = lineto(L X,Y) ：画直线到指定的坐标位置H = horizontal lineto(H X)：画水平线到指定的X坐标位置V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线S = smooth curveto(S X2,Y2,ENDX,ENDY)：三次贝赛曲线Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射前面路径后的终点A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线Z = closepath()：关闭路径 恶心的兼容问题 Android 5.0 (API 21) 开始使用的矢量图，现在google大大可以将矢量图兼容到API7，需要注意的点是新的兼容库support-vector-drawablew在你的app等级的build.gradle添加的版本要在23.2.0+ , 同时还要在你的build.gradle (version 2.0+) 配置 12345android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125;&#125; ImageView、ImageButton 将 android:src 替换成 app:srcCompat 代码中设置的话同样的道理 imageView.setImageResource(R.drawable.vector_image); Button 使用 background:&quot;@drawable/selector&quot; 好像也有个坑 首先你的activity 继承自 AppCompatActivity 然后加上 123static &#123; AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);&#125; 这样好像才能解决掉这个的 Selector 的问题，当然有时候莫名其妙的遇不到这些问题，用的时候注意下这个问题就好。 ​","tags":[{"name":"SVG","slug":"SVG","permalink":"/dayanguai.website/tags/SVG/"}]},{"title":"抓包并且分析一个app(一)","date":"2017-02-22T10:16:32.000Z","path":"2017/02/22/2017-02-22-抓包/","text":"上篇抓出来魅族音乐的api,但是由于自己是在边查边弄得一个状态,所以干脆写到博客上,给自己留个备份…… 首先抓包需要一个抓包工具 我的是mac 用的是Charles, 破解下载地址在这 Charles 然后看下自己的本机代理ip 然后在手机WiFi设置 -&gt; 代理设置 -&gt; 手动设置 -&gt; 服务器(查看Charles的ip) -&gt; 端口(默认8888) 去看咱们的Charles 工具 会出现咱们抓取的数据 看下抓到的数据 红色已经标注下来了,自己乱点点，就能看到一些host,params,以及respones 什么的网络请求啦~ 然后过滤抓取数据 这里可以自己添加过滤信息 虽然写的很简单，其实软件一看就明白了。0.0 然后就可以抓取自己的信息了，但是不乏人家有加密的，目前 是木有办法去解决去，阿嘞~","tags":[{"name":"反编译","slug":"反编译","permalink":"/dayanguai.website/tags/反编译/"}]},{"title":"音乐API(魅族音乐)","date":"2017-02-19T08:28:27.000Z","path":"2017/02/19/2017-02-19-抓出来的音乐API-md/","text":"魅族手机音乐API（如有侵权删）最近想写个音乐播放器，但是没有好的api支持，所有抓了魅族音乐的api 分页起始位置 和 分页数量 都是int 值，版本号我这里是 5.0, 所有未标注的请求方式都死GET 请求 API_HOST : http://fast.y.meizu.com/ 启动根据版本号拿到版本id /open/api/v2/ui/index.do?v={版本号} 根据版本id返回的首页id去请求乐库id /open/api/v2/ui/detail.do?id={版本id}&amp;start=0&amp;limit=1 根据返回的乐库id请求乐库数据 /open/api/v2/ui/detail.do?id={乐库id}&amp;start=0&amp;limit=10 乐库首页 音乐播放（播放需要参数，参数是反编译，读源码出来的,有些不准确） POST 请求/open/api/v2/song/getAudioInfo/{musicId}/0/1/19220771 params stamp : deviceId + EBL22MDZK(没读出来这段) + System.currentTimeMillis() version : v2 _musiccodeurl : /open/api/v2/song/getAudioInfo/{musicId}/0/1/19220771 sign ：MD5加密字符串 sign 需要做点处理，将上面三个的key 按照ASCII 拍下序，然后 12345678910StringBuilder localStringBuilder = new StringBuilder(\"MEIZU\"); for (int i = 0; i &lt; paramList.size(); i++) &#123; String value = paramList.get(i).getValue(); //将每个value拼接上去 localStringBuilder.append(value); if (i &lt; paramList.size() - 1) &#123; localStringBuilder.append(\"@\"); //然后以@拼接 &#125; &#125;localStringBuilder.append(\"MUSIC\"); //最后拼接上MUSICMD5Util.parseStrToMd5L32(localStringBuilder.toString()); //最后将字符串转换成32为的MD5小写字符串 ​ 搜索 /open/api/v2/search/vsearch.do?q={搜索key}&amp;geoloc=null&amp;include_optimum=true&amp;page={分页数目}&amp;limit={分页数量}&amp;installed_apps=[]&amp;search_Types=[3] 歌单（start 是分页标志,双数[0,2,4,6]） 热门歌单: /open/api/v2/ui/content.do?id={热门歌单id}&amp;start={分页起始位置}&amp;limit={分页数量} 歌单活动： /open/api/v2/ui/detail.do?id={歌单活动id}&amp;start={分页起始位置}&amp;limit={分页数量} 歌单详情 歌单详情: /open/api/v2/songList/detail/{歌单id}} 歌单详情列表： /open/api/v2/songList/songs/{歌单id}}/{分页起始位置}}/{分页数量} 歌单评论列表： /open/api/v2/comment/commentList.do?id={歌单id}}&amp;type={type}&amp;source=0&amp;startId=0&amp;limit={分页数量} 排行榜： open/api/v2/ui/detail.do?id={排行榜id}&amp;start={分页起始位置}&amp;limit={分页数量} {类别}榜 /open/api/v2/category/getCategoryRes.do?categoryId={类别id}&amp;start={分页起始位置}&amp;limit={分页数量}&amp;startId=0 歌曲电台(电台播放暂时还未去抓取) 获取电台类别id /open/api/v2/ui/detail.do?id={电台id}&amp;start={分页起始位置}&amp;limit={分页数量} {电台类别id} /open/api/v2/ui/detail.do?id={类别id}&amp;start={分页起始位置}&amp;limit={分页数量} 电台详情 /open/api/v2/category/getCategoryRes.do?categoryId={电台id}&amp;start={分页起始位置}&amp;limit={分页数量}&amp;startId=0","tags":[{"name":"API","slug":"API","permalink":"/dayanguai.website/tags/API/"}]},{"title":"Android-ADB(开发常用)","date":"2017-02-05T07:02:58.000Z","path":"2017/02/05/2017-02-05-Android-ADB(开发常用)/","text":"这是自己常用的一些常用的adb命令(虽然不是特别的准确，但是基本够用了。。。) adb 查看当前设备连接 1adb devices adb 重启手机 12adb reboot //手机重启adb reboot bootloader //重启手机到引导模式 adb 服务启动 12adb kill-server //杀死掉adb进程adb start-server //启动adb进程 adb 安装应用 12adb install com.xxx.xxx //直接安装adb install -r com.xxx.xxx //保留数据安装 adb 卸载应用 1adb uninstall com.xxx.xxx adb 清除应用信息 1adb shell pm clear com.xxx.xxx adb 日志查看 12adb logcat //所有的日志输出adb logcat | grep OkHttp //表示拦截 OkHttp 的日志 adb 查看当前显示的前台 Activity 1adb shell dumpsys window windows | grep -E \"mCurrentFocus\" adb 传输 12adb pull /sdcard/夏目友人帐 ~/Desktop夏目友人帐 //从手机导入到电脑adb push ~/Desktop/夏目友人帐 /sdcard/夏目友人帐 //从电脑传输到手机 adb 启动Activity 1adb shell am start com.xxx.xxx/com.xxx.xxx.source.login.WelcomeActivity //启动某个应用的launcher页面 列出当前手机的所有应用 这个我是目前用的最多的几个命令，mm， 这个这个github的讲解的比较详细，可以从这学习下,mm","tags":[{"name":"adb命令","slug":"adb命令","permalink":"/dayanguai.website/tags/adb命令/"}]},{"title":"Android-Animaion_两张图片实现剪切逐进动画","date":"2017-01-21T10:07:27.000Z","path":"2017/01/21/2017-01-21-Android-Animaion-两张图片实现剪切逐进动画/","text":"使用ValueAnimator实现逐渐覆盖的动画 在写项目的时候有语音播放的动画，跟着语音长度来展示波形动画，功能时间短，然后直接两张波形图，然后去逐渐剪切覆盖来进行展示动画(先看效果) 其实看到这个动画我是懵B的，这咋写，想想方法吧 首先是两张图，下面一张，上面一张，然后动画时间是语音的时长，随着时间走，上面一张逐渐覆盖下面一张(当然两张是一样大小的) 上面的那张图片是宽度在逐渐变大，使用ValueAnimator 动画控制View的宽度逐渐变大 图片宽度变大时候去裁剪图片的宽度，裁剪的宽度就是valueAnimator.getAnimatedValue() 的数值 思路是出来了，那么，写代码吧。 布局文件先写出来 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingLeft=\"50dp\" android:paddingTop=\"50dp\"&gt; &lt;ImageView android:id=\"@+id/bottom_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/siri_graph_grey\"/&gt; &lt;ImageView android:id=\"@+id/top_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\"/&gt; &lt;Button android:id=\"@+id/animation_crop\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"100dp\" android:text=\"开始\"/&gt;&lt;/FrameLayout&gt; 当然两张图片是重合的，需要裁剪的图片先让它隐藏掉 然后咱们应该拿出图片的宽度吧 代码 1234567mBottomImage.post(new Runnable() &#123; @Override public void run() &#123; //获取控件的宽度 mVoiceImageWidth = mBottomImage.getMeasuredWidth(); &#125; &#125;); 在onCreate()方法去拿一个控件的宽度有很多种方法，就先这个吧，但是，我要是在列表的时候去播放的时候再去拿宽度，拿到的肯定是0吧，其实要拿的就是那个图片的宽度，可以在onCreate()里面这样去拿 12 bitmapOrg = BitmapFactory.decodeResource(getResources(), R.drawable.siri_graph_blue);//去拿bitmap的宽度，就是咱们控件的宽度(前提是当前控件是wrap_content) 这样可以拿出需要的宽度，那么写动画吧，看代码 1234567891011121314151617181920212223242526272829303132333435363738private void animation() &#123; /* 录音的动画 */ mView.setVisibility(View.VISIBLE); animator = ValueAnimator.ofInt(0, mVoiceImageWidth); animator.addUpdateListener( new ValueAnimator.AnimatorUpdateListener() &#123; @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN) @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //得到的值 int value = (Integer) valueAnimator.getAnimatedValue(); //拿到当前View的布局参数 ViewGroup.LayoutParams params = mView.getLayoutParams(); //将得到的动画的偏移量的值设置为当前控件的宽度 params.width = value; params.height = mBottomImage.getHeight(); mView.setLayoutParams(params); //裁剪图片 BitmapDrawable drawable = cropImage(value); //将图片设置到View上 mView.setBackground(drawable); &#125; &#125; ); //动画结束的时候将界面还原 animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mView.setVisibility(View.GONE); &#125; &#125;); animator.setDuration(4000); animator.setInterpolator(new LinearInterpolator()); animator.start(); &#125; 那么需要裁剪的图片的宽度就是动画的偏移量的值，上代码： 12345678910111213141516/**** 裁剪图片 记得try起来，会抛出一个异常*/private BitmapDrawable cropImage(int voiceImageWidth) &#123; BitmapDrawable bd = null; try &#123; //需要裁剪的宽度 int targetWidth = voiceImageWidth; //重新创建一个新的Bitmap Bitmap resizedBitmap = Bitmap.createBitmap(bitmapOrg, 0, 0, targetWidth, bitmapOrg.getHeight()); /*将bitmap转换成一个resource资源 */ bd = new BitmapDrawable(resizedBitmap); &#125; catch (Exception e) &#123; System.out.println(\"Error1 : \" + e.getMessage() + e.toString()); &#125; &#125; 好了代码就这么多，然后就需要看结果了！ 其实把思路理清楚了，然后看看Android API 就可以喽，没写过几次博客，勿喷，23333","tags":[{"name":"Android动画","slug":"Android动画","permalink":"/dayanguai.website/tags/Android动画/"}]},{"title":"Android开发中遇到的一些的小点","date":"2017-01-03T02:17:13.000Z","path":"2017/01/03/2017-01-03-Android开发中遇到的一些的小点/","text":"碰到ScrollView嵌套ListView或者RecyclerView优先选择添加head,而不要去嵌套，否则出现Item的高度的问题(ps:以前的刚入门的问题,记下来了,大神略过); android:clipToPadding 我们在用到ListView 或者RecyclerView的时候，需求是需要有一个内边距的需求,而用padding的时候会有一个白色的内边距，这时候我们就可以用到ListView、RecyclerView的强大的属性android:clipToPadding=&quot;false&quot;, 默认情况下android:clipToPadding=&quot;true&quot; clipToPadding的解释： Defines whether the ViewGroup will clip its children and resize (but not clip) any EdgeEffect to its padding, if padding is not zero. API 定义ViewGroup是否将剪切其子项，并将任何EdgeEffect调整大小（但不剪裁）为其填充 adb命令 Android查看运行的前台界面的activity 1adb shell dumpsys window windows | grep -E \"mCurrentFocus'\" Android手机WIFI去感叹号 1adb shell \"settings put global captive_portal_server Android 6.0查看当前手机的危险权限： 1adb shell pm list permissions -g -d ​ 图片的压缩 在做一个项目的时候,ui妹妹给了icon的图,打开一看4M多,吓得我赶紧压缩)下图片 CardView的Padding兼容(AndroidL以上和L以下的版本显示的padding不一致) 12app:cardPreventCornerOverlap=\"true\"app:cardUseCompatPadding=\"true\" 显示密码 android中有的时候需要显示密码,怕自己忘记 12edittext.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); //显示密码edittext.setTransformationMethod(PasswordTransformationMethod.getInstance()); //隐藏密码 DrawLayout 侧边栏有的时候会有一层黑色的遮罩 1mDrawLayout.setScrimColor(getResources().getColor(android.R.color.transparent)); TextView默认上下室友一定的Padding，有时候我们并不需要空白，加上下面这条属性： 1includeFontPadding=\"false\" android:animateLayoutChanges酷炫的属性，如果触发layout()(比如它的子View为GONE),系统会默认加上布局改变时的动画特效； RecyclerView的布局管理器，其实在布局文件中也可以添加 1app:layoutManager=\"android.support.v7.widget.RecyclerView.LayoutManager\" android studio 中新创建的java Moudle 使用System.out.print()方法时候，中文会出现乱码的问题(加上下面这句就行)： 123tasks.withType(JavaCompile) &#123; options.encoding = \"UTF-8\"&#125; Android 5.0背景涟漪效果： 12?android:attr/selectableItemBackground 有界限的波纹?android:attr/selectableItemBackgroundBorderless 可以超出视图区域的波纹 android.os.Build 类包含了我们常用的一些系统的东西，比如说机型号，版本号，基带版本什么的 123456builder.append(\"手机品牌\" + android.os.Build.BRAND + \"\\n\");builder.append(\"手机的型号 设备名称\" + android.os.Build.MODEL + \"\\n\");builder.append(\"设备制造商\" + android.os.Build.MANUFACTURER + \"\\n\");builder.append(\"系统版\" + android.os.Build.VERSION.RELEASE + \"\\n\");builder.append(\"设备版本号\" + android.os.Build.ID + \"\\n\");builder.append(\"设备的唯一标识\" + android.os.Build.FINGERPRINT + \"\\n\"); 这篇文章会持续更新~","tags":[{"name":"Android","slug":"Android","permalink":"/dayanguai.website/tags/Android/"}]}]